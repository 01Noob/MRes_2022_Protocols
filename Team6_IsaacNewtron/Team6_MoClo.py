from opentrons import protocol_api, simulate
import math
import numpy as np
import csv


# Specify arguments here
# Volume of each DNA part to use in assembly (75-100ng optimal)
part_volume = 1
# If set to true, will use 1 tip per part, and wash between each aspiration/dispensation
reuse_tips = False
# Specify reservoir format. Names must be unique. Each well in the assembly plate will contain
# one DNA part for each group. MM (master mix) will be added to each well, and should contain 
# everything except the DNA parts (i.e. water and GG master mix in the correct ratio, and also 
# opetionally the destination vector). This csv_raw can be generated by opening a csv file with 
# a text editor and copy-pasting it here. MM, wash1, and wash2 are protected variables and 
# cannot be used for part or group names - only use for master mix and wash reservoirs.
csv_raw = '''
A_wt,A_mut,B_wt,B_mut,C_wt,C_mut,D_wt,D_mut,MM,wash1,wash2
1,1,2,2,3,3,4,4,MM,wash1,wash2
A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12
'''

csv_data = csv_raw.splitlines()[1:] # Discard the blank first line.
csv_data = [i.split(',') for i in csv_data]

def cartesian(arrays, out=None):
    
    '''function generates all DNA combinations such that every combination contains
    one part from each group, and every group is represented'''
    arrays = [np.asarray(x) for x in arrays]
    dtype = arrays[0].dtype

    n = np.prod([x.size for x in arrays])
    if out is None:
        out = np.zeros([n, len(arrays)], dtype=dtype)

    m = int(n / arrays[0].size) 
    out[:,0] = np.repeat(arrays[0], m)
    if arrays[1:]:
        cartesian(arrays[1:], out=out[0:m, 1:])
        for j in range(1, arrays[0].size):
        #for j in xrange(1, arrays[0].size):
            out[j*m:(j+1)*m, 1:] = out[0:m, 1:]
    return out


row_dict = {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E', 5: 'F', 6: 'G', 7: 'H'}

metadata = {'apiLevel': '2.7'}
def run(protocol: protocol_api.ProtocolContext):
    
    # Creates dictionary of name: (group, well) from csv
    myDict = {}
    for name, group, well in zip(csv_data[0], csv_data[1], csv_data[2]):
        myDict[name] = (group, well)

    # Creates dictionary of group: [list of names in group]
    group_dict = {}
    for name, tup in myDict.items():
        if tup[0] in group_dict.keys():
            group_dict[tup[0]].append(name)
        else:
            group_dict[tup[0]] = [name]

    # Generates all combinations using cartesian from group_dict
    combs = cartesian((gr_list for gr_list in group_dict.values()))

    # Specify special wells
    MM_well = myDict['MM'][1]
    if reuse_tips:
        wash_1 = myDict['wash1'][1]
        wash_2 = myDict['wash2'][1]

    # Create dictionary with the wells to pipette into for each DNA sequence
    well_dict = {name: [] for name in csv_data[0] if name not in ['MM', 'wash1', 'wash2']}
    for i, comb in enumerate(combs):
        for name in csv_data[0]:
            if name in comb and name not in ['MM', 'wash1', 'wash2']:
                well_dict[name].append(i)

    # Initialise labware
    reservoir = protocol.load_labware('4ti0136_96_wellplate_2200ul', 3)
    tc_mod = protocol.load_module('Thermocycler Module')
    plate_thermo = tc_mod.load_labware('4ti0960rig_96_wellplate_200ul')
    tips20 = protocol.load_labware('opentrons_96_tiprack_20ul', 2)

    p20 = protocol.load_instrument('p20_single_gen2', 'right', tip_racks=[tips20])

    tc_mod.open_lid()

    # Calculate volume of master mix in each well for a total volume of 20 ul
    MM_vol = 20 - len(group_dict)
    
    # Pipette MM into each well
    p20.pick_up_tip()
    for i in range(len(combs)):
        well_loc = row_dict[math.floor(i/12)] + str(i%12 + 1)
        p20.aspirate(MM_vol, reservoir[MM_well].bottom(0.5))
        p20.dispense(MM_vol, plate_thermo[well_loc])
        p20.blow_out()
    p20.drop_tip()


    # Move parts to wells in all combinations
    for name, well_list in well_dict.items():
        if reuse_tips:
            p20.pick_up_tip()
            for j in well_list:
                well_loc = row_dict[math.floor(j/12)] + str(j%12 + 1)
                p20.aspirate(part_volume, reservoir[myDict[name][1]].bottom(0.5))
                p20.dispense(part_volume, plate_thermo[well_loc])
                p20.blow_out()
                
                # Wash steps allow tip recycling
                p20.mix(2, 5, reservoir[wash_1].bottom(0.5))
                p20.blow_out()
                p20.mix(2, 5, reservoir[wash_2].bottom(0.5))
                p20.blow_out()
            p20.drop_tip()
        else:
            for j in well_list:
                well_loc = row_dict[math.floor(j/12)] + str(j%12 + 1)
                p20.transfer(1, reservoir[myDict[name][1]].bottom(0.5), plate_thermo[well_loc], blow_out=True)

    tc_mod.close_lid()
    tc_mod.set_lid_temperature(temperature=75)

    # GoldenGate protocol
    for i in range(30):
        tc_mod.set_block_temperature(37, hold_time_minutes=1)
        tc_mod.set_block_temperature(16, hold_time_minutes=1)
    tc_mod.set_block_temperature(60, hold_time_minutes=5)
    tc_mod.set_block_temperature(4, hold_time_minutes=5)
    tc_mod.open_lid()
    tc_mod.deactivate()